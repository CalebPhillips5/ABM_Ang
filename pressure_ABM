#include "general_libraries.h"
#include "cell_abm.h"
#include "main_abm_oxy.h"
#include "chrono"

//###########################################################################
//                    0  - Dead Cells
//                    1  - Tumor Cells
//                    2  - Proliferative Tumor Cells
//                    3  - Hypoxic Tumor Cells
//                    4  - Dying Tumor Cells
//                    5  - G1 Tumor Cells
//                    6  - Normoxic Cells
//                    7  - Endothelial Cells
//                    8  - Tip Cells
//                    9  - Stalk Cells
// 		      10 - Activated Tip Cells
// 		      11 - Growing Stalk Cells
//###########################################################################

vector<Cell> Cells_global;

Number exact_value_ox(const Point& ,const Parameters& ,const std::string& ,const std::string& ){return 0.0;}
Number exact_value_vessel(const Point& ,const Parameters& ,const std::string& ,const std::string& ){return 0.0;}
double triangle_area(const Point& e1,const Point& e2,const Point& e3){return 0.5*fabs((e1(0)-e3(0))*(e2(1)-e1(1))-(e1(0)-e2(0))*(e3(1)-e1(1)));}
//double triangle_area(const Point& e1,const Point& e2,const Point& e3){return 0.5*fabs(  e1(0)*(e2(1)-e3(1)) + e2(0)*(e3(1)-e1(1)) + e3(0)*(e1(1)-e2(1)) );}
double scalar_prod(const Point& e1,const Point& e2){return e1(0)*e2(0)+e1(1)*e2(1);}

void main_code(int argc, char** argv,MPI_Comm lib_comm,vector<double> Parameters,int file_number){
  // The parameters follow this order
  //double nut_d,double nut_coeff,double con_t,double vegf_diff,double vegf_prod,double vegf_cons
  //========== Initialize the library ==========
  LibMeshInit init (argc, argv,lib_comm);
  //========== Declare cells list ==========****
  list <Cell> Cells_local;
  list <Cell> Cells_vessel_start;
  list <Cell> Cells_vessel_end;
  list <Cell*> Tip_local;
  vector<Cell> Cells_tip;
  //========== Read argumments ==========
  GetPot input_file("options.in");
  const bool read_solution         = input_file("read_solution",0);
  const bool verbose               = input_file("verbose",0);
  const bool unbreakable           = input_file("unbreakable",0);
  const bool deactivation          = input_file("deactivation",0);
  const bool anastomosis           = input_file("anastomosis",0);
  const int max_tip_cells          = input_file("max_tip_cells",100);
  const bool dirichlet             = input_file("dirichlet",0);
  const unsigned int n_elements    = input_file("n_elements",20);
  const unsigned int n_timesteps   = input_file("n_timesteps",100);
  const unsigned int initial_tum   = input_file("initial_tum",20);
  int init_timestep                = input_file("init_timestep",0);
  const unsigned int print_inter   = input_file("print_inter",100);
  const unsigned int ic_type       = input_file("ic_type",1);
  const unsigned int rand_seed     = input_file("rand_seed",7);
  const unsigned int max_outside   = input_file("max_outside",1500);
  const std::string mesh_name      = input_file("mesh_name", "rec_struct.msh");
  const unsigned int read_mesh     = input_file("read_mesh",0);
  const double initial_con         = input_file("initial_con",20.0);
  const double con_b               = input_file("con_b",1.0);
  const double con_n               = input_file("con_n",1.0);
  const double end_r               = input_file("end_r",1.0);
  const double domain_diameter     = input_file("domain_diameter",1.0);
  const double time_step           = input_file("time_step",0.05);
  const double prol_intens         = input_file("prol_intens",1.0);
  const double nucleus_radius      = input_file("nucleus_radius",5.295);
  const double cell_radius         = input_file("cell_radius",9.953);
  const double action_prop         = input_file("action_prop",1.214);
  const double c_ccr               = input_file("c_ccr",10.0);
  const double c_eea               = input_file("c_eea",0.588836);
  const double mesh_x              = input_file("mesh_x",800);
  const double mesh_y              = input_file("mesh_y",400);
  //int tip_cell_c                   = input_file("tip_cell_c",0);
  Ran ran(rand_seed);
  int outside_cells = 0;
  int total_tumor = initial_tum;
  char buffer[30];
  char buffer2[30];
  ofstream out_data;
  std::stringstream cell_holder;
  std::string extension = ".txt";
  //cell_holder << "cells_dice_test" << file_number << extension;
  //std::string file = cell_holder.str();
  //out_data.open(file);
  ofstream dice;
  std::stringstream cell_hold;
//  cell_hold << "dice" << t_step << extension;
  cell_hold << "dice" << file_number << extension;
  std::string dice_file = cell_hold.str();
  dice.open(dice_file);

  /*ofstream out_data2;
  std::stringstream cell_holder2;
  cell_holder2 << "density" << file_number << extension;
  std::string file2 = cell_holder2.str();
  out_data2.open(file2); */
  //========== Create a uniform mesh ==========
  SerialMesh mesh(init.comm());
  if(!read_solution){
    if(read_mesh){
      mesh.read(mesh_name);
    }
    else{
cout <<"made it to here" << endl;
      MeshTools::Generation::build_cube (mesh,
					 n_elements,
					 n_elements,
					 0,
					 0., mesh_x,
					 0., mesh_y,
					 0., 0.,
					 QUAD9);
cout <<"and made it out!" << endl;
      mesh.write("mesh.msh");
    }
  }
  else{
    mesh.read(mesh_name);
  }
  if(verbose){mesh.print_info();}
  double H_MAX = 0;
  MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
  const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
  for ( ; el != end_el ; ++el){
    const Elem* elem = *el;
    if(H_MAX<elem->hmax())
      H_MAX = elem->hmax();
  }
  //========== Create an equation systems object and set a simulation-specific parameter ==========
  //0 - nut_d, 1 - nut_coeff, 2 - con_t, 3 - vegf_diff, 4 - vegf_prod, 5 - vegf_cons
  //
  EquationSystems equation_systems(mesh);
  equation_systems.parameters.set<Real> ("vegf_ths")        = Parameters[0];
  equation_systems.parameters.set<Real> ("vegf_diff")       = Parameters[1];
  equation_systems.parameters.set<Real> ("vegf_cons")       = Parameters[2]; //  pg/mL per hour per cell 
  equation_systems.parameters.set<Real> ("vegf_prod")       = Parameters[3]; // 0.08477 pg/mL per hour per cell
//  equation_systems.parameters.set<Real> ("tip_distance")    = Parameters[4];
  equation_systems.parameters.set<Real> ("tip_distance")    = 8;

//  equation_systems.parameters.set<Real> ("vegf_diff")       = 600;
//  equation_systems.parameters.set<Real> ("vegf_diff")         = 419; // microns^2 / 10 minutes PSYCH THIS IS 6 MINUTES
//  equation_systems.parameters.set<Real> ("vegf_cons")       = 0.001; //  pg/mL per hour per cell 
//  equation_systems.parameters.set<Real> ("vegf_cons")       = Parameters[1];
  //equation_systems.parameters.set<Real> ("tip_distance")    = Parameters[3];
  equation_systems.parameters.set<Real> ("tau_E_time")      = 24;
  equation_systems.parameters.set<Real> ("stalk_divide_time")   = 24;
  equation_systems.parameters.set<Real> ("stalk_growth_time")      = 6;

  equation_systems.parameters.set<Real> ("nut_coeff")       = 0;//3.5*Parameters[3];
  equation_systems.parameters.set<Real> ("nut_d")           = 200.0;
  equation_systems.parameters.set<Real> ("con_t")           = 2.0;
  //equation_systems.parameters.set<Real> ("vegf_prod")       = Parameters[0];
  
  equation_systems.parameters.set<Real> ("c_ccr")           = c_ccr;
  equation_systems.parameters.set<Real> ("c_eea")           = c_eea;
//  equation_systems.parameters.set<Real> ("nut_coeff")       = 0;
 // equation_systems.parameters.set<Real> ("vegf_ths")        = vegf_ths;
  //equation_systems.parameters.set<Real> ("tip_distance")    = Parameters[1];
  equation_systems.parameters.set<Real> ("repulsion_distance")    = 1.1;
  equation_systems.parameters.set<Real> ("con_b")           = con_b;
  equation_systems.parameters.set<Real> ("con_n")           = con_n;
  equation_systems.parameters.set<Real> ("end_r")           = end_r;
  equation_systems.parameters.set<Real> ("time_step_size")  = time_step;
  equation_systems.parameters.set<int>  ("initial_tumor")   = total_tumor;
  equation_systems.parameters.set<bool> ("deactivation")    = deactivation;
  equation_systems.parameters.set<bool> ("unbreakable")     = unbreakable;
  equation_systems.parameters.set<bool> ("anastomosis")     = anastomosis;
  equation_systems.parameters.set<int>  ("max_tip_cells")   = max_tip_cells;
  equation_systems.parameters.set<int>  ("ic_type")         = ic_type;
  equation_systems.parameters.set<Real> ("initial_con")     = initial_con;
  equation_systems.parameters.set<Real> ("nucleus_radius")  = nucleus_radius;
  equation_systems.parameters.set<Real> ("cell_radius")     = cell_radius;
  equation_systems.parameters.set<Real> ("action_radius")   = action_prop*cell_radius;
  equation_systems.parameters.set<Real> ("apop_time")       = 8.6;
//  equation_systems.parameters.set<Real> ("g1_time")         = 9.0;
  equation_systems.parameters.set<Real> ("g1_time")         = 13.0;
  equation_systems.parameters.set<Real> ("lysing_time")     = 6.0;
  equation_systems.parameters.set<Real> ("calc_time")       = 360.0;
//  equation_systems.parameters.set<Real> ("cellc_time")      = 18.0;
  equation_systems.parameters.set<Real> ("cellc_time")      = 18.0;
  equation_systems.parameters.set<Real> ("hypoxic_thrs")    = 0.3;
  equation_systems.parameters.set<Real> ("prol_intes")      = prol_intens/1.921166667;
  equation_systems.parameters.set<Real> ("apop_intes")      = 1.0/786.61;
  equation_systems.parameters.set<Real> ("delta_tt")        = 1.0;
  equation_systems.parameters.set<Real> ("f_NS")            = 1.0;
  equation_systems.parameters.set<Real> ("lambda_cell")     = 0.1;
  equation_systems.parameters.set<Real> ("domain_diameter") = domain_diameter;
  equation_systems.parameters.set<Real> ("max_out_cells")   = max_outside;
  equation_systems.parameters.set<Real> ("h_max_mesh")      = H_MAX;
  equation_systems.parameters.set<Real> ("mesh_x")          = mesh_x;
  equation_systems.parameters.set<Real> ("mesh_y")          = mesh_y;

  equation_systems.parameters.set<list <Cell> *>("l_cells") = &Cells_local;
  //========== Declare the system ==========
  TransientLinearImplicitSystem &vegf     = equation_systems.add_system<TransientLinearImplicitSystem> ("VEGF");
  TransientLinearImplicitSystem &nutr     = equation_systems.add_system<TransientLinearImplicitSystem> ("Nutrient");
  TransientLinearImplicitSystem &vessel   = equation_systems.add_system<TransientLinearImplicitSystem> ("Vessel");
  TransientLinearImplicitSystem &pressure = equation_systems.add_system<TransientLinearImplicitSystem> ("Pressure");
  ExplicitSystem &velocity                = equation_systems.add_system<ExplicitSystem>("Velocity");
  TransientLinearImplicitSystem &drug     = equation_systems.add_system<TransientLinearImplicitSystem>("Drug");
  if(!read_solution){
    //========== Timestep always 0 ==============
    init_timestep = 0;
    //========== Declare the variables ==========
    unsigned int v_var    = vegf.add_variable("vegf_var", FIRST);
    unsigned int nut_var  = nutr.add_variable("nut_var", FIRST);
    unsigned int ves_var  = vessel.add_variable("ves_var", FIRST);
    unsigned int pres_var = pressure.add_variable("pres_var", SECOND);
    unsigned int drug_var = drug.add_variable("drug_var", FIRST);
    velocity.add_variable("vel_x", FIRST);
    velocity.add_variable("vel_y", FIRST);
    //nutr.add_variable("nut_var", FIRST);
    //========== Matrix assembly and initial condition functions ==========
    vegf.attach_assemble_function(assemble_vegf);
    drug.attach_assemble_function(assemble_vegf);
    nutr.attach_assemble_function(assemble_ox);
    pressure.attach_assemble_function(assemble_pressure);
    drug.attach_assemble_function(assemble_drug);
    nutr.attach_init_function(initial_condition_ox);
//  I dont' believe pressure needs an intitial condition,
//  since it doesn't evolve in time in the classical sense.
//  vessel.attach_assemble_function(assemble_vessel);
//  vegf.attach_init_function(initial_condition_vegf);
//  vessel.attach_init_function(initial_condition_vessel);
    //========== Initialize the data structures for the equation system ==========
    // Let's set pressure to 1 on the top serface.
    // I'm not actually sure that the mesh has anything
    // like this labeled. Maybe set everything to 1..? Lol
    std::set<boundary_id_type> boundary_ids_one;
    if(read_mesh){
      boundary_ids_one.insert(0);
    }
    else{
      boundary_ids_one.insert(0);
      boundary_ids_one.insert(1);
      boundary_ids_one.insert(2);
      boundary_ids_one.insert(3);
    }
    std::vector<unsigned int> variables;
    variables.push_back(v_var);
    ConstFunction<Number> bc_value(0.0);
    std::vector<unsigned int> vessel_variables;
    vessel_variables.push_back(ves_var);
    ConstFunction<Number> bcves_value(0.0);
    //std::vector<unsigned int> pressure_variables;
    //pressure_variables.push_back(pres_var);
    //ConstFunction<Number> bcpres_value(0.0);
    if(dirichlet){
      DirichletBoundary dirichlet_bc_one(boundary_ids_one,variables,&bc_value);
      vegf.get_dof_map().add_dirichlet_boundary(dirichlet_bc_one);
      DirichletBoundary dirichlet_bc_two(boundary_ids_one,vessel_variables,&bcves_value);
      vessel.get_dof_map().add_dirichlet_boundary(dirichlet_bc_two);
    }
    //DirichletBoundary dirichlet_bc_pres(boundary_ids_one,pressure_variables,&bcpres_value);
    //pressure.get_dof_map().add_dirichlet_boundary(dirichlet_bc_pres);
    std::vector<unsigned int> variablesn;
    variablesn.push_back(nut_var);
    ConstFunction<Number> bcnut_value(1.0);
    //DirichletBoundary dirichlet_bc_two(boundary_ids_one,variablesn,&bcnut_value);
    //nutr.get_dof_map().add_dirichlet_boundary(dirichlet_bc_two);
    equation_systems.init();
    init_cond_cells(Cells_local,equation_systems.parameters,ran);
  }
  else{
    std::stringstream ss;
    std::string ext = ".e";
    ss << "saved_solution" << file_number << "_" << setfill('0') << setw(5) << init_timestep << ext;
    std::string results = ss.str();
    //equation_systems.read(results, libMeshEnums::READ);
    equation_systems.read(results);
    vegf.update();
    nutr.update();
 //   vessel.update();
    //========== Initialize the data structures for the equation system ==========
    unsigned int v_var = vegf.variable_number("vegf_var");
    unsigned int nut_var = nutr.variable_number("nut_var");
    unsigned int ves_var = vessel.variable_number("ves_var");
    unsigned int pres_var = pressure.add_variable("pres_var", SECOND);
    unsigned int drug_var = drug.add_variable("drug_var", FIRST);
    velocity.add_variable("vel_x", FIRST);
    velocity.add_variable("vel_y", FIRST);
    std::set<boundary_id_type> boundary_ids_one;
    if(read_mesh){
      boundary_ids_one.insert(0);
    }
    else{
      boundary_ids_one.insert(0);
      boundary_ids_one.insert(1);
      boundary_ids_one.insert(2);
      boundary_ids_one.insert(3);
    }
    std::vector<unsigned int> variables;
    variables.push_back(v_var);
    ConstFunction<Number> bc_value(0.0);
    std::vector<unsigned int> vessel_variables;
    variables.push_back(ves_var);
    ConstFunction<Number> bcves_value(0.0);
    //std::vector<unsigned int> pressure_variables;
    //pressure_variables.push_back(pres_var);
    //ConstFunction<Number> bcpres_value(1.0);
    if(dirichlet){
      DirichletBoundary dirichlet_bc_one(boundary_ids_one,variables,&bc_value);
      vegf.get_dof_map().add_dirichlet_boundary(dirichlet_bc_one);
      DirichletBoundary dirichlet_bc_two(boundary_ids_one,vessel_variables,&bcves_value);
      vessel.get_dof_map().add_dirichlet_boundary(dirichlet_bc_two);
    }
    //DirichletBoundary dirichlet_bc_pres(boundary_ids_one,pressure_variables,&bcpres_value);
    //pressure.get_dof_map().add_dirichlet_boundary(dirichlet_bc_pres);
    DirichletBoundary dirichlet_bc_two(boundary_ids_one,vessel_variables,&bcves_value);
    vessel.get_dof_map().add_dirichlet_boundary(dirichlet_bc_two);
    std::vector<unsigned int> variablesn;
    variablesn.push_back(nut_var);
    ConstFunction<Number> bcnut_value(1.0);
    //DirichletBoundary dirichlet_bc_two(boundary_ids_one,variablesn,&bcnut_value);
    //nutr.get_dof_map().add_dirichlet_boundary(dirichlet_bc_two);
    vegf.attach_assemble_function(assemble_vegf);
    nutr.attach_assemble_function(assemble_ox);
    pressure.attach_assemble_function(assemble_pressure);
    drug.attach_assemble_function(assemble_drug);
//    vessel.attach_assemble_function(assemble_vessel);
    equation_systems.reinit();
    std::stringstream abm;
    std::string extension = ".txt";
    abm << "results" << file_number << "_" << setfill('0') << setw(5) << init_timestep << extension;
    std::string Caleb = abm.str();
    restart_function(Cells_local,Tip_local,Caleb);
  }
  if(verbose){
    equation_systems.print_info();
    sprintf(buffer, "exo%d.e",file_number);
    ExodusII_IO(mesh).write_equation_systems(buffer,equation_systems);
    save_cells(Cells_local,domain_diameter,"saida",file_number,0);
    print_order(Cells_local,domain_diameter,"output",file_number,init_timestep);
    save_grad_vegf(equation_systems,"grad_vegf",file_number,0);
    //out_data << 0.0 << " " << Cells_global.size() << " " << total_tumor << " " << outside_cells << " " << initial_con << endl;
/*
    const std::vector<double> vec;
    vessel.write_serialized_vector(io,&vec);
    springf(buffer,"field_test.txt");
    for(int caleb = 0; caleb < vec.size(); caleb++){
       out_data2 << vec[caleb] << endl;
    }
*/	

  }
  //========== Loop over time ==========
  unsigned int t_step = init_timestep;
  do{
    //========== Increase time_step counter ==========
    //cout << "time_step = " << t_step << ", file_number = " << file_number << endl;
    t_step++;
    vegf.time = t_step*time_step;
    nutr.time = t_step*time_step;
    vessel.time = t_step*time_step;
    drug.time = t_step*time_step;
    //========== Copy solution of previous time step ==========
    *vegf.old_local_solution = *vegf.current_local_solution;
    *nutr.old_local_solution = *nutr.current_local_solution;
    *drug.old_local_solution = *drug.current_local_solution;
    *vessel.old_local_solution = *vessel.current_local_solution;

cout << "pre-update_states: file number = " << file_number << endl;
    //========== Solve ABM system ==========
if( t_step < 3000 ){
    update_states(Cells_local,Tip_local,Cells_vessel_start,Cells_vessel_end,t_step,ran,equation_systems,outside_cells);
cout << "post-update_states: file number = " << file_number << endl;


    if(verbose && t_step%print_inter==0){
      print_order(Cells_local,domain_diameter,"output",file_number,-t_step);
    }
    compute_forces(Cells_local,Tip_local,Cells_vessel_start,Cells_vessel_end,equation_systems,domain_diameter,outside_cells,t_step);
cout << "post-compute_forces: final number = " << file_number << endl;
    /////----- Solve systems -----/////
//    if( t_step%2==0){
//    vegf.solve();
cout << "post-vegf: final number = " << file_number << endl;

if(verbose && t_step%print_inter==0){
auto start = std::chrono::steady_clock::now();
    pressure.solve();
auto end = std::chrono::steady_clock::now();
std::chrono::duration<double> elapsed_seconds = end-start;
cout << "pressure_compute time: = " << elapsed_seconds.count() << endl;
//cout << "post-pres " << endl;
//    compute_velocity(equation_systems);
cout << "post-vel " << endl;
//     drug.solve();
}

}else{

   // compute drug delivery equation
     drug.solve();

}




//    nutr.solve();
//    }

//cout << "post-solve" << endl;

    if(verbose && t_step%print_inter==0){
      save_cells(Cells_local,domain_diameter,"saida",file_number,t_step);
      print_order(Cells_local,domain_diameter,"output",file_number,t_step);
      save_grad_vegf(equation_systems,"grad_vegf",file_number,t_step);
      //-- Save system to restart later --//
      std::stringstream abm;
      std::string extension = ".txt";
      abm << "results" << file_number << "_" << setfill('0') << setw(5) << t_step << extension;
      std::string Caleb = abm.str();
      restart_save(Cells_local,Caleb);
      std::stringstream ss;
      std::string ext = ".e";
      ss << "saved_solution" << file_number << "_" << setfill('0') << setw(5) << t_step << ext;
      std::string results = ss.str();
      libmesh_assert_equal_to(libMesh::processor_id(), 0);
      //equation_systems.write(results, libMeshEnums::WRITE);
      equation_systems.write(results);
      //========== Write output to paraview ==========
      ExodusII_IO exo(mesh);
      exo.append(true);
      exo.write_timestep(buffer, equation_systems, t_step+1, vegf.time);
//}
/*
  ofstream dice;
  std::stringstream cell_hold;
//  cell_hold << "dice" << t_step << extension;
  cell_hold << "paper_generate_flow" << t_step << extension;
  std::string dice_file = cell_hold.str();
  dice.open(dice_file);
      vector<double> dice_vec((mesh_x-1)*(mesh_y-1));
      double area; 
      get_dice_vec(equation_systems,t_step,dice_vec,area);
      for(int caleb = 0; caleb < dice_vec.size(); caleb++){
	  //out_data2 << dice_vec[caleb] << endl;
	  dice << dice_vec[caleb] << endl;
      } */
}
    double confluence = 0.;
    int Quiescent = 0, Proliferative = 0, Hypoxic = 0, Necrotic = 0, Stalk = 0, Endothelial = 0;
    std::list<Cell>::iterator it;
    for(it = Cells_local.begin(); it != Cells_local.end(); ++it){
      confluence += std::pow((*it).C_radius,2)/std::pow(0.5*domain_diameter,2);
      if((*it).state == 1) Quiescent += 1;
      if((*it).state == 2) Proliferative += 1;
      if((*it).state == 3) Hypoxic += 1;
      if((*it).state == 0) Necrotic += 1;
      if((*it).state == 9 || (*it).state == 11) Stalk += 1;
      if((*it).state == 7) Endothelial += 1;
    }
    int total_t = Quiescent + Proliferative + Hypoxic + Necrotic;
    if(verbose){
      cout << "==================================================" << endl;
      cout << "Confluence          = " << confluence << endl;
      cout << "Number of cells     = " << Cells_local.size() << endl;
      cout << "Tumor cells         = " << total_t << endl;
      cout << "Necrotic cells      = " << Necrotic << endl; // 5
      cout << "Quiescent cells     = " << Quiescent << endl; // 2
      cout << "Proliferative cells = " << Proliferative << endl; // 3 
      cout << "Hypoxic cells       = " << Hypoxic << endl; // 4
      cout << "Endothelial cells   = " << Endothelial << endl; // 7
      cout << "Tip cells           = " << Tip_local.size() << endl; // 1
      cout << "Stalk cells         = " << Stalk << endl; // 6
      cout << "Outside cells       = " << outside_cells << endl;
      cout << "Time                = " << t_step << endl;
      cout << "==================================================" << endl;
    }
    //out_data << t_step << " " << Necrotic << " " << Quiescent << " " << Proliferative << " " << Hypoxic << " " << Endothelial << " " << Tip_local.size() << " " << Stalk << endl;
  }while(t_step<n_timesteps);
  const Real vegf_ths = equation_systems.parameters.get<Real>("vegf_ths");
  const Real vegf_diff = equation_systems.parameters.get<Real>("vegf_diff");
  const Real vegf_cons = equation_systems.parameters.get<Real>("vegf_cons");
  const Real tip_distance = equation_systems.parameters.get<Real>("tip_distance");
  dice << vegf_ths << " " << vegf_diff << " " << vegf_cons << " " << tip_distance << endl;
  //out_data.close();
  //out_data2.close();
  Cells_global.clear();
}

void save_grad_vegf(EquationSystems& es,string s,int file_number,int t){
  const char *c = s.c_str();
  char n[100],name[200];
  sprintf(n,"%d_%05d.m",file_number,t);
  strcpy(name,c);
  strcat(name,n);
  stringstream ss;
  string name_s;
  ss << name;
  ss >> name_s;
  ofstream out_file;
  out_file.open (name_s);
  //=======*** Saving the data =====***==//
  const MeshBase& mesh = es.get_mesh();
  out_file << "grad = zeros(" << mesh.n_elem() << "," << 4 << ");" <<endl;
  out_file << "grad = [";
  const unsigned int dim = mesh.mesh_dimension();
  TransientLinearImplicitSystem & system = es.get_system<TransientLinearImplicitSystem>("VEGF");
  const unsigned int v_nut = system.variable_number("vegf_var");
  const DofMap& dof_map = system.get_dof_map();
  FEType fe_type = dof_map.variable_type(0);
  UniquePtr<FEBase> fe (FEBase::build(dim, fe_type));
  QGauss qrule (dim, fe_type.default_quadrature_order());
  fe->attach_quadrature_rule (&qrule);
  const std::vector<std::vector<RealGradient> >& dphi = fe->get_dphi();
  std::vector<dof_id_type> dof_indices;
  std::vector<dof_id_type> dof_indices_nut;
  MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
  const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
  for ( ; el != end_el ; ++el){
    const Elem* elem = *el;
    dof_map.dof_indices(elem,dof_indices);
    dof_map.dof_indices(elem,dof_indices_nut,v_nut);
    fe->reinit(elem);
    unsigned int qp=0;
    Gradient gradient_vegf;
    for(unsigned int l=0; l<dof_indices.size(); l++){
      gradient_vegf.add_scaled(dphi[l][qp], system.old_solution(dof_indices[l]));
    }
    out_file << elem->centroid()(0) << " " << elem->centroid()(1) << " " << gradient_vegf(0) << " " << gradient_vegf(1) << endl;
  }
  out_file << "];";
  out_file.close();
}

void compute_velocity(EquationSystems& es){
  const MeshBase & mesh = es.get_mesh();
  const unsigned int dim = mesh.mesh_dimension();
  // To compute velocity, we need u = -k(x)\grad(p)
  // we need vessel to compute k(x)
  // we need pressure to compute \grad(p)
  TransientLinearImplicitSystem & ves_sys  = es.get_system<TransientLinearImplicitSystem>("Vessel");
  TransientLinearImplicitSystem & pres_sys = es.get_system<TransientLinearImplicitSystem>("Pressure");
  ExplicitSystem & vel_sys                 = es.get_system<ExplicitSystem>("Velocity");
//cout << "check 1" <<endl;
  unsigned int velocity_vars[2];
  velocity_vars[0] = vel_sys.variable_number ("vel_x");
  velocity_vars[1] = vel_sys.variable_number ("vel_y");
  const DofMap& velocity_dof_map = vel_sys.get_dof_map();
  std::vector<dof_id_type> velocity_dof_indices_var;
//cout << "check 2" <<endl;
  
  const DofMap& dof_map = pres_sys.get_dof_map();
  FEType fe_type = dof_map.variable_type(0);
  UniquePtr<FEBase> fe (FEBase::build(dim, fe_type));
  QGauss qrule (dim, fe_type.default_quadrature_order());
  fe->attach_quadrature_rule (&qrule);
  std::vector<dof_id_type> dof_indices;
//cout << "check 3" <<endl;

  const std::vector<std::vector<Real>> & phi = fe->get_phi();
  const std::vector<std::vector<RealGradient>> & dphi = fe->get_dphi();
  const std::vector<Real>& JxW = fe->get_JxW();  
//cout << "check 4" <<endl;
  
  MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
  const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
  for ( ; el != end_el ; ++el){
    const Elem* elem = *el;
    dof_map.dof_indices(elem,dof_indices);
    fe->reinit(elem);
    double k_0 = 1.0; // tissue permeability
    double k_S = 1.0; // vessel surface permeability
    double k_V = 100.0;  // vessel permeability
    double kappa = 0;
    Gradient velocity_grad = 0.;
//    cout << "check 5" <<endl;
    for(unsigned int qp=0; qp<qrule.n_points(); qp++){
        double vessel_value = 0;
      for(unsigned int l=0; l<dof_indices.size(); l++){
         vessel_value += phi[l][qp]*ves_sys.current_solution(dof_indices[l]);
      } // dof


 /*    if( vessel_value >= 0.9){
          kappa = k_0 + k_V*vessel_value;
      }else if( vessel_value >= 0.1 && vessel_value <= 0.9){
          kappa = k_S; //  + k_V*vessel_value;
     } else
          kappa = k_0;  */
    kappa = k_0 + k_V*vessel_value;

//      kappa = 1.0 * pow(10,4);

      for(unsigned int l=0; l<dof_indices.size(); l++){
//    cout << "check 8" <<endl;

        velocity_grad.add_scaled(dphi[l][qp],-kappa*pres_sys.current_solution(dof_indices[l]));
//    cout << "check 9" <<endl;
      } // dof
     //vel_sys.solution->set(dof_indices, velocity_quad);
    } // quadrature points
    
    for(unsigned int j=0; j<2; j++){
	  velocity_dof_map.dof_indices (elem, velocity_dof_indices_var, velocity_vars[j]);
	  dof_id_type dof_index = velocity_dof_indices_var[0];
	  if( (vel_sys.solution->first_local_index() <= dof_index) && (dof_index < vel_sys.solution->last_local_index()) ){
	    vel_sys.solution->set(dof_index, velocity_grad(j));
	  }
    }
      
  } // element

}

void assemble_vegf(EquationSystems& es,const std::string& libmesh_dbg_var(system_name)){
  libmesh_assert_equal_to (system_name, "VEGF");
  const MeshBase& mesh = es.get_mesh();
  const unsigned int dim = mesh.mesh_dimension();
  TransientLinearImplicitSystem & system = es.get_system<TransientLinearImplicitSystem>("VEGF");
  TransientLinearImplicitSystem &ves = es.get_system<TransientLinearImplicitSystem>("Vessel");
  const unsigned int v_nut = system.variable_number("vegf_var");
  const Real time_size = es.parameters.get<Real>("time_step_size");
  const Real vegf_diff = es.parameters.get<Real>("vegf_diff");
  const Real vegf_prod = es.parameters.get<Real>("vegf_prod");
  const Real vegf_cons = es.parameters.get<Real>("vegf_cons");
//cout << " in assemble_vegf vegf_cons = " << vegf_cons << endl;
  const Real ac_radius = es.parameters.get<Real>("action_radius");
  const Real h_max_msh = es.parameters.get<Real>("h_max_mesh");
  const Real height    = es.parameters.get<Real>("domain_diameter");
  const Real mesh_x    = es.parameters.get<Real>("mesh_x");
  const Real mesh_y    = es.parameters.get<Real>("mesh_y");
  list <Cell> *Cells_local = es.parameters.get<list <Cell> *>("l_cells");
  const double h_bin   = ac_radius+h_max_msh;
  const int number_bins0 = ceil(mesh_x/h_bin);
  const int number_bins1 = ceil(mesh_y/h_bin);
  const int total_bins  = number_bins0*number_bins1;
  //========== Generate bins ==========
  vector< list < Cell * > > Cell_Bins(total_bins);
  std::list<Cell>::iterator it;
  for(it = Cells_local->begin(); it != Cells_local->end(); ++it){
    int ix = floor((*it).x/h_bin);
    int jy = floor((*it).y/h_bin);
    int xy = ix+jy*number_bins0;
    if((*it).x<0 || (*it).y<0 || (*it).x> mesh_x || (*it).y> mesh_y || jy>=number_bins1 || ix>=number_bins0 || xy >=total_bins){
      cout << "Error" << endl;
      cout << "Cell = ( " << (*it).x << " , " << (*it).y << " ) = ( " << ix << " , " << jy << " ) = " << xy << endl;
      cout << "State = " << (*it).state << endl;
      cout << "total_bins  = " << total_bins << endl;
      cout << "number_bins0 = " << number_bins0 << endl;
      cout << "number_bins1 = " << number_bins1 << endl;
      cout << "h_bin       = " << h_bin << endl;
      getchar();
    }
    Cell_Bins[xy].push_back(&*it);
  }
  //========== Continue stnd ==========
 // cout << "honestly no idea what's happening" << endl;
  const DofMap& dof_map = system.get_dof_map();
  FEType fe_type = dof_map.variable_type(0);
  UniquePtr<FEBase> fe (FEBase::build(dim, fe_type));
  QGauss qrule (dim, fe_type.default_quadrature_order());
  fe->attach_quadrature_rule (&qrule);
  const std::vector<Real>& JxW = fe->get_JxW();
  const std::vector<std::vector<Real> >& phi = fe->get_phi();
  const std::vector<std::vector<RealGradient> >& dphi = fe->get_dphi();
  DenseMatrix<Number> Ke;
  DenseVector<Number> Fe;
  std::vector<dof_id_type> dof_indices;
  std::vector<dof_id_type> dof_indices_nut;
  MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
  const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
// cout << "yeah?" << endl;
  for ( ; el != end_el ; ++el){
    const Elem* elem = *el;
    //========== Computed volume fraction ==========
    Point e_center = elem->centroid();
    int ix = floor(e_center(0)/h_bin);
    int jy = floor(e_center(1)/h_bin);
    double p_t,p_n,p_h,p_e,p_s;
    double elem_volume = elem->volume();
    p_t = p_n = p_h = p_e = p_s = 0.;
    for(int xx = -1; xx<=1; xx++){
      if(ix+xx>=0 && ix+xx<number_bins0){
	for(int yy = -1; yy<=1; yy++){
	  if(jy+yy>=0 && jy+yy<number_bins1){
	    int bin_xy = (ix+xx)+(jy+yy)*number_bins0;
	    std::list<Cell*>::iterator cell_ab;
	    for(cell_ab = Cell_Bins[bin_xy].begin(); cell_ab != Cell_Bins[bin_xy].end(); ++cell_ab){
	      if( (*(*cell_ab)).state == 0 || (*(*cell_ab)).state == 4) continue;
	      else{
		Point p( (*(*cell_ab)).x,(*(*cell_ab)).y,0.);
		double area_computed = 0.;
//		if(elem->type()==3){
//		  area_computed = area_inside_tri(p,elem->point(0),elem->point(1),elem->point(2),(*(*cell_ab)).C_radius,elem_volume);
//		}
//		else{
cout <<"area_computed? " <<endl;
cout <<"nope " <<endl;
		  area_computed = area_inside_quad(p,elem->point(0),elem->point(1),elem->point(2),elem->point(3),(*(*cell_ab)).C_radius);

//		}
// this is the area computed for the element but really I want to divide area_computed by area_cell
		if(area_computed > 0){
double area = 3.1415926535* pow( (*(*cell_ab)).C_radius,2);
//2		  if((*(*cell_ab)).state == 6) p_n+=(area_computed/elem_volume);
		  if((*(*cell_ab)).state == 6) p_n+=(area_computed/area);
		  else if((*(*cell_ab)).state == 3) p_h+=(area_computed/area);
		  else if((*(*cell_ab)).prev_state == 7) p_e+=(area_computed/area);
		  else if((*(*cell_ab)).state == 9) p_e+=(area_computed/area);
		  else if((*(*cell_ab)).state == 11) p_e+=(area_computed/area);
		  else if((*(*cell_ab)).state == 8) p_e+=(area_computed/area);
		  else if((*(*cell_ab)).prev_state == 13) p_e+=(area_computed/area);
		  else if((*(*cell_ab)).prev_state == 14) p_e+=(area_computed/area);
		  else p_t+=(area_computed/area);
		}
	      }
	    }
	  }
	}
      }
    }
// p_e still lives here.
cout << "is it vessel" << endl;
//     if(p_e > 0 || (e_center(0) >= 2.254*20+35-9.953/2.0 && e_center(0) <= 2.254*20+58+9.953/2.0) ){
//     if(p_e > 0 || (e_center(0) >= 2 && e_center(0) <= 2.254*20+23+9.953/2.0) ){
     if(p_e > 0 || (e_center(0) >= 2 && e_center(0) <=28+9.953/2.0) ){
cout <<"did it fail in vessel loop?" <<endl;
        for(unsigned int caleb = 0; caleb<elem->n_nodes(); caleb++){
          vector<double> value(1);
          vector<unsigned int> position(1,elem->node_id(caleb));
          (ves.solution)->get(position,value);
          (ves.solution)->set(elem->node_id(caleb),1);//value[0]+0.1*(1.0-value[0]));
cout << "value = " << value[0] << endl;
        }
cout <<"nope, not fail in vessel loop" <<endl;
     }

//cout << " yes it vessel" << endl;
 /*else{
cout << " is it vessel" << endl;
        for(unsigned int caleb = 0; caleb<elem->n_nodes(); caleb++){
          vector<double> value(1);
          vector<unsigned int> position(1,elem->node(caleb));
          (ves.solution)->get(position,value);
          (ves.solution)->set(elem->node(caleb),0);
	}
     }*/
	

    //========== Continue stnd ==========    
    dof_map.dof_indices(elem,dof_indices);
    dof_map.dof_indices(elem,dof_indices_nut,v_nut);
    fe->reinit(elem);
    Ke.resize(dof_indices.size(),dof_indices.size());
    Fe.resize(dof_indices.size());
//cout << "vegf_cons = " << vegf_cons << ", p_e = " << p_e << endl;
    for (unsigned int qp=0; qp<qrule.n_points(); qp++){
      Number vegf_old = 0.0;
      for(unsigned int l=0; l<phi.size(); l++){
	vegf_old += phi[l][qp]*system.old_solution(dof_indices_nut[l]);
      }
      for (unsigned int i=0; i<phi.size(); i++){
	Fe(i) += JxW[qp]*(vegf_old
			  +time_size*p_h*vegf_prod
			  )*phi[i][qp];
	for (unsigned int j=0; j<phi.size(); j++){
	  Ke(i,j) += JxW[qp]*time_size*vegf_diff*dphi[i][qp]*dphi[j][qp];
	  Ke(i,j) += JxW[qp]*(1.0+time_size*(p_h*vegf_prod+(p_e+p_s)*vegf_cons))*phi[i][qp]*phi[j][qp];
	}
      }
    }
//cout << "pre fancy" << endl;
    dof_map.heterogenously_constrain_element_matrix_and_vector(Ke,Fe,dof_indices);
    system.matrix->add_matrix (Ke,dof_indices);
    system.rhs->add_vector    (Fe,dof_indices);
//cout << "post fancy" << endl;
  }
}


void assemble_drug(EquationSystems& es,const std::string& libmesh_dbg_var(system_name)){
  libmesh_assert_equal_to (system_name, "Drug");
  const MeshBase& mesh = es.get_mesh();
  const unsigned int dim = mesh.mesh_dimension();
  TransientLinearImplicitSystem &system  = es.get_system<TransientLinearImplicitSystem>("Drug");
  TransientLinearImplicitSystem &vessel  = es.get_system<TransientLinearImplicitSystem>("Vessel");
  TransientLinearImplicitSystem &vegf    = es.get_system<TransientLinearImplicitSystem>("VEGF");



  ExplicitSystem &vel_sys  = es.get_system<ExplicitSystem>("Velocity");
  const unsigned int u_var = vel_sys.variable_number ("vel_x");
  const unsigned int v_var = vel_sys.variable_number ("vel_y");


  const unsigned int v_drug = system.variable_number("drug_var");
  const Real time_size = es.parameters.get<Real>("time_step_size");
  const Real vegf_diff = es.parameters.get<Real>("vegf_diff");
  const Real vegf_prod = es.parameters.get<Real>("vegf_prod");
  const Real vegf_cons = es.parameters.get<Real>("vegf_cons");
  const Real ac_radius = es.parameters.get<Real>("action_radius");
  const Real h_max_msh = es.parameters.get<Real>("h_max_mesh");
  const Real height    = es.parameters.get<Real>("domain_diameter");
  const Real mesh_x    = es.parameters.get<Real>("mesh_x");
  const Real mesh_y    = es.parameters.get<Real>("mesh_y");
  list <Cell> *Cells_local = es.parameters.get<list <Cell> *>("l_cells");
  const double h_bin   = ac_radius+h_max_msh;
  const int number_bins0 = ceil(mesh_x/h_bin);
  const int number_bins1 = ceil(mesh_y/h_bin);
  const int total_bins  = number_bins0*number_bins1;
  const DofMap& dof_map = system.get_dof_map();
  const DofMap& dof_vel = vel_sys.get_dof_map();
  FEType fe_type = dof_map.variable_type(0);
  UniquePtr<FEBase> fe (FEBase::build(dim, fe_type));
  UniquePtr<FEBase> fe_face (FEBase::build(dim, fe_type));
  QGauss qrule (dim, fe_type.default_quadrature_order());
  QGauss qface (dim-1, fe_type.default_quadrature_order());
  fe->attach_quadrature_rule (&qrule);
  fe_face->attach_quadrature_rule (&qface);
  const std::vector<Real>& JxW = fe->get_JxW();
  const std::vector<Real>& JxW_face = fe_face->get_JxW();
  const std::vector<std::vector<Real> >& phi = fe->get_phi();
  const std::vector<std::vector<RealGradient> >& dphi = fe->get_dphi();
  const std::vector<std::vector<Real> >& phi_face = fe_face->get_phi();
  const std::vector<std::vector<RealGradient> >& dphi_face = fe_face->get_dphi();
  const std::vector<Point> & qface_points = fe_face->get_xyz();
  const std::vector<Point> & normals = fe_face->get_normals();
  DenseMatrix<Number> Ke;
  DenseVector<Number> Fe;
  std::vector<dof_id_type> dof_indices;
  std::vector<dof_id_type> dof_indices_drug;

  std::vector<dof_id_type> dof_indices_u;
  std::vector<dof_id_type> dof_indices_v;

  MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
  const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

  double x_min = 35;   // 12*2.2;
  double x_max = 58;   // 20*2.2;
  double y_min = mesh_y - (250+12.2);
  double y_max = mesh_y - 250;
  double y_max_out = 12.2;
  double y_min_out = 0;

  for ( ; el != end_el ; ++el){
    const Elem* elem = *el;
    Point e_center = elem->centroid();
    int ix = floor(e_center(0)/h_bin);
    int jy = floor(e_center(1)/h_bin);
    double p_t,p_n,p_h,p_e,p_s;
    double elem_volume = elem->volume();
    p_t = p_n = p_h = p_e = p_s = 0.;

    dof_map.dof_indices(elem,dof_indices);
    dof_map.dof_indices(elem,dof_indices_drug,v_drug);
   dof_vel.dof_indices(elem,dof_indices_u,u_var);
   dof_vel.dof_indices(elem,dof_indices_v,v_var);
    fe->reinit(elem);
    Ke.resize(dof_indices.size(),dof_indices.size());
    Fe.resize(dof_indices.size());
    for (unsigned int qp=0; qp<qrule.n_points(); qp++){
      Gradient grad_drug_old;
      Number drug_old = 0.0;
      RealVectorValue vel_sol;
      Number velocity_x = 0.0;
      Number velocity_y = 0.0;
      for(unsigned int l=0; l<phi.size(); l++){
        drug_old += phi[l][qp]*system.old_solution(dof_indices_drug[l]);
        grad_drug_old.add_scaled(dphi[l][qp], system.old_solution (dof_indices[l]));
        vel_sol(0) += phi[l][qp]*vel_sys.current_solution(dof_indices_u[l]);
        vel_sol(1) += phi[l][qp]*vel_sys.current_solution(dof_indices_v[l]);

      }

      for (unsigned int i=0; i<phi.size(); i++){

       bool matrix_set = 0;
       Fe(i) += JxW[qp]*(drug_old)*phi[i][qp];


        for (unsigned int j=0; j<phi.size(); j++){

            vector<double> vessel_value(1);
            for(unsigned int caleb = 0; caleb < elem->n_nodes(); caleb++)
               {
                  vector<unsigned int> position(1,elem->node_id(caleb));
                  (vessel.solution)->get(position,vessel_value);
                    if(vessel_value[0] >= 1)
                       vessel_value[0] = 1;
               }

             double diff_ves = 1000.0;
             double diff_tissue = 10.0;
             double diffusion = diff_tissue + diff_ves*vessel_value[0];

          Ke(i,j) += JxW[qp]*time_size*(diffusion)*dphi[i][qp]*dphi[j][qp];

          Ke(i,j) += JxW[qp]*(1.0)*phi[i][qp]*phi[j][qp];
          Ke(i,j) += JxW[qp]*vel_sol*dphi[j][qp]*phi[i][qp];
          double h = 2.254;
          double h_min = elem->hmin();
          double h_max = elem->hmax();
          double anorm =  sqrt( pow( vel_sol(0) , 2) + pow(vel_sol(1),2) );
          double Pe = h_max*anorm / (2*diffusion);
          double tau = (h_max/(2*anorm)) * (1/tanh(Pe) - 1/(Pe) );
          Ke(i,j) += JxW[qp]*tau* (vel_sol*dphi[j][qp])* vel_sol*dphi[i][qp];


      }// j 
    }// i 
    }// qp


        if(system.time < 4*0.05)
         {
        double value = 0.;
        for(auto s : elem->side_index_range())
          if(elem->neighbor_ptr(s) == nullptr)
            {
              Point e_center = elem->centroid();
            if( e_center(0) <= 2.254*20+58 && e_center(0) >= 2.254*20+35 && system.time < 10)
              {
                fe_face->reinit(elem, s);

              if( e_center(1) > 100){
                 value = 1.e-2;
              }else if( e_center(1) < 100){
              }

               if( abs(value) > .0001 ){

                for (unsigned int qp=0; qp<qface.n_points(); qp++)
                  {
cout << "system.time = " << system.time << endl;
                    for (std::size_t i = 0; i<phi.size(); i++)
                        Fe(i) += JxW_face[qp]*value*phi_face[i][qp];

                  }
                 }
               }
              }
          }


    dof_map.heterogenously_constrain_element_matrix_and_vector(Ke,Fe,dof_indices);
    system.matrix->add_matrix (Ke,dof_indices);
    system.rhs->add_vector    (Fe,dof_indices);
  }
}


void assemble_pressure(EquationSystems& es,const std::string& libmesh_dbg_var(system_name)){
  libmesh_assert_equal_to (system_name, "Pressure");
  const MeshBase& mesh = es.get_mesh();
  const unsigned int dim = mesh.mesh_dimension();
  TransientLinearImplicitSystem & system = es.get_system<TransientLinearImplicitSystem>("Pressure");
  TransientLinearImplicitSystem & vessel = es.get_system<TransientLinearImplicitSystem>("Vessel");
  const unsigned int pres_nut = system.variable_number("pres_var");
  const Real time_size = es.parameters.get<Real>("time_step_size");
  const Real mesh_x = es.parameters.get<Real>("mesh_x");
  const Real mesh_y = es.parameters.get<Real>("mesh_y");
/* I don't think any of this is necessary
*/
  //========== Continue stnd ==========
  const DofMap& dof_map = system.get_dof_map();
  FEType fe_type = dof_map.variable_type(0);
  UniquePtr<FEBase> fe (FEBase::build(dim, fe_type));
  UniquePtr<FEBase> fe_face (FEBase::build(dim, fe_type));
  QGauss qrule (dim, FIFTH); // fe_type.default_quadrature_order());
  QGauss qface (dim-1, FIFTH);//fe_type.default_quadrature_order());
  fe->attach_quadrature_rule (&qrule);
  fe_face->attach_quadrature_rule (&qface);
  const std::vector<Real>& JxW = fe->get_JxW();
  //const std::vector<Real>& JxW_face = fe_face->get_JxW();
  const std::vector<std::vector<Real> >& phi = fe->get_phi();
  //const std::vector<std::vector<Real> >& psi = fe_face->get_phi();
  const std::vector<std::vector<RealGradient> >& dphi = fe->get_dphi();
 // const std::vector<Point> & qface_points = fe_face->get_xyz();
  DenseMatrix<Number> Ke;
  DenseVector<Number> Fe;
  std::vector<dof_id_type> dof_indices;
//  std::vector<dof_id_type> dof_indices_nut;
  MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
  const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
  double x_min = 12*2.2;
  double x_max = 20*2.2;
  double y_min = mesh_y - 12.2;
  double y_max = mesh_y;
  double y_max_out = 12.2;
  double y_min_out = 0;
auto start2 = std::chrono::steady_clock::now(); 
       // check inlet conditions
  for ( ; el != end_el ; ++el){
    const Elem* elem = *el;
    //========== Computed volume fraction ==========
    // Here is the element centroid.. is that enough information? 
    Point e_center = elem->centroid();
    //========== Continue stnd ==========    
    dof_map.dof_indices(elem,dof_indices);
//    dof_map.dof_indices(elem,dof_indices_nut,pres_nut);
const unsigned int n_dofs =
        cast_int<unsigned int>(dof_indices.size());

//cout << "n_dofs = " << n_dofs << endl;

    fe->reinit(elem);
libmesh_assert_equal_to (n_dofs, phi.size());
 //   Ke.resize(dof_indices.size(),dof_indices.size());
    Ke.resize(n_dofs,n_dofs);
    Fe.resize(n_dofs);
    for (unsigned int qp=0; qp<qrule.n_points(); qp++){
      Number nut_old      = 0.0;
      Number nut_cur      = 0.0;

      for (unsigned int i=0; i != n_dofs; i++){
              
       // I think I can do my boundary conditions here
          Fe(i) += 0; // nut_old+nut_old*(1-nut_old)*time_size*p_e;

       // these are the conditions for the inlet condition
       bool   matrix_set = 0; 
 
       // check inlet conditions
       /*
       if( e_center(0) < x_max && e_center(0) > x_min && e_center(1) < y_max && e_center(1) > y_min){
            // set Ke(i,i) = 1
            // set Ke(i,j) = 0;        
             Fe(i) = 1;
             matrix_set = 1; 
       //  cout << "we located the centroid of an element for inlet condition" << endl;
       // check outlet conditions
       }else if( e_center(0) < x_max && e_center(0) > x_min && e_center(1) < y_max_out && e_center(1) > y_min_out){
            // set Ke(i,i) = 1
            // set Ke(i,j) = 0;        
             Fe(i) += 0; 
             matrix_set = 1; 
        // cout << "we located the centroid of an element for outlet condition" << endl;
       } */
	for (unsigned int j=0; j != n_dofs; j++){

         // Here we're just solving Darcy
         // permeability kappa = k_0 + vessel*k_V

/*          vector<double> vessel_value(1);
          for(unsigned int caleb = 0; caleb< elem->n_nodes(); caleb++){
         //    vector<double> vessel_value(1);
             vector<unsigned int> position(1,elem->node_id(caleb)); 
             (vessel.solution)->get(position,vessel_value);
             if (vessel_value[0] >= 1)
                 vessel_value[0] = 1;

          } */
          double k_0 = 1 * pow(10,-3); // tissue permeability
          double k_V = 1 * pow(10,-3);  // vessel permeability
          double kappa = k_0;// + k_V*vessel_value[0]; 

         /* if( vessel_value[0] >= 0.5 ){
             cout << "kappa >= 0.5 = " << kappa << endl;
          }else{ 
             cout << "kappa  = " << kappa << endl;
          }*/ 

//          if (matrix_set == 0){
            // don't set the boundary
            Ke(i,j) = JxW[qp]*dphi[i][qp]*dphi[j][qp]*kappa;
 /*         }else{
          // set the boundary condition                
            if (i==j){
              Ke(i,j) = 1;
         //     cout << "we set Ke(i,j) = 1" << endl;
            }else{
              Ke(i,j) = 0;
          //    cout << "we set Ke(i,j) = 0" << endl;
            }
          } */
	  } // end j
	} // end i 
      } // end qp

    /*        const Real penalty = 1.e10;
        double value = 2.0;
        for(auto s : elem->side_index_range())
          if(elem->neighbor_ptr(s) == nullptr)
            {
              Point e_center = elem->centroid();
            if( e_center(0) <= 2.254*20+58 && e_center(0) >= 35+ 2.254*20 )
              {
                fe_face->reinit(elem, s);

              if( e_center(1) > 100){
                 value = 0.0;
              }else if( e_center(1) < 100){
                 value = 1.0;
              }
                if( abs(value) < 1.5  || abs(value) > 2.5){

                for (unsigned int qp=0; qp<qface.n_points(); qp++)
                  {

                    for (std::size_t i = 0; i<phi.size(); i++)
                        Fe(i) += penalty*JxW_face[qp]*value*psi[i][qp];


                    for (std::size_t i = 0; i<phi.size(); i++)
                       for (std::size_t j = 0; j<phi.size(); j++)
                           Ke(i,j) += penalty*JxW_face[qp]*psi[i][qp]*psi[j][qp];
                  }
                }
              }
	      } */


    {

      // The following loop is over the sides of the element.
      // If the element has no neighbor on a side then that
      // side MUST live on a boundary of the domain.
      for (auto side : elem->side_index_range())
	if (elem->neighbor_ptr(side) == nullptr)
	  {
	    // The value of the shape functions at the quadrature
	    // points. 
	    
//          if( e_center(0) <= 2.254*20+58 && e_center(0) >= 35+ 2.254*20 )
//          if( e_center(0) <= 28+9.954/2 && e_center(0) >= 0 && (e_center(1) > mesh_y-8 || e_center(1) < 8))
          if( e_center(0) <= mesh_x && e_center(0) >= 0 && (e_center(1) > mesh_y-elem->length(0,1) || e_center(1) < elem->length(0,1)))
	   {
cout << "DO ANY OF THEM ACTUALLY MAKE IT IN HERE WHAT IS GOING ON" << endl;
	    const std::vector<std::vector<Real>> & phi_face = fe_face->get_phi();

	    // The Jacobian * Quadrature Weight at the quadrature
	    // points on the face.
	    const std::vector<Real> & JxW_face = fe_face->get_JxW();

	    // The XYZ locations (in physical space) of the
	    // quadrature points on the face.  This is where
	    // we will interpolate the boundary value function.
	    const std::vector<Point> & qface_point = fe_face->get_xyz();

	    // Compute the shape function values on the element
	    // face.
	    fe_face->reinit(elem, side);

	    // Some shape functions will be 0 on the face, but for
	    // ease of indexing and generality of code we loop over
	    // them anyway
            libmesh_assert_equal_to (n_dofs, phi_face.size());

	    // Loop over the face quadrature points for integration.
	    for (unsigned int qp=0; qp<qface.n_points(); qp++)
	      {
		// The location on the boundary of the current
		// face quadrature point.
		//		const Real xf = qface_point[qp](0);
		//const Real yf = qface_point[qp](1);

		// The penalty value.  \frac{1}{\epsilon}
		// in the discussion above.
		const Real penalty = 1.e10;

		// The boundary value.
		double value = 2.0; //  exact_solution(xf, yf);

                if(e_center(1) > mesh_y-8){
			value = 1.0;
 			cout << "are we actually trying to change the value = 1?" << endl;
                }
		if(e_center(1) < 8){
			value = 0.0;
 			cout << "are we actually trying to change the value = 0?" << endl;
		}
		// Matrix contribution of the L2 projection.
		for (unsigned int i=0; i != n_dofs; i++)
		  for (unsigned int j=0; j != n_dofs; j++)
		    Ke(i,j) += JxW_face[qp]*penalty*phi_face[i][qp]*phi_face[j][qp];

		// Right-hand-side contribution of the L2
		// projection.
		for (unsigned int i=0; i != n_dofs; i++)
		  Fe(i) += JxW_face[qp]*penalty*value*phi_face[i][qp];
	      }
           }
	  }
    }


    dof_map.heterogenously_constrain_element_matrix_and_vector(Ke,Fe,dof_indices);
    system.matrix->add_matrix (Ke,dof_indices);
    system.rhs->add_vector    (Fe,dof_indices);
  } // end elem
auto end2 = std::chrono::steady_clock::now();
std::chrono::duration<double> elapsed_seconds2 = end2-start2;
cout << "element loop pressure time := " << elapsed_seconds2.count() << endl;
}


double area_inside_quad(const Point& p,const Point& e1,const Point& e2,const Point& e3,const Point& e4,double radius){
  double elem_volumeA = triangle_area(e1,e2,e3);
  double elem_volumeB = triangle_area(e3,e4,e1);
  double area_div = area_inside_tri(p,e1,e2,e3,radius,elem_volumeA)+area_inside_tri(p,e3,e4,e1,radius,elem_volumeB);
  return area_div;
}

double area_inside_tri(const Point& p,const Point& e1,const Point& e2,const Point& e3,double radius,double elem_volume){
  //========== Check if the center of the cell is inside the element ==========
  int cs_inside = 0;
  double test_area = triangle_area(p,e1,e2)+triangle_area(p,e1,e3)+triangle_area(p,e2,e3);
  if(fabs(elem_volume-test_area)<=1.e-10) cs_inside = 1;
  //========== Define some parameters ========================================*
  double chord[3];
  double angle;
  double area_cs[3];
  double area_t[3];
  std::vector<unsigned int> vert_inside;
  std::vector<unsigned int> vert_out;
  std::vector<unsigned int> edge_inside;
  std::vector<unsigned int> edge_out;
  double area_circ = M_PI*pow(radius,2);
  Point v_e[3];
  v_e[0].add(e1);v_e[1].add(e2);v_e[2].add(e3);
  double t_e[3][2];  
  int part_edge[3][2];
  for(int i=0;i<3;i++){
    for(int j=0;j<2;j++){
      part_edge[i][j]=0;
      t_e[i][j]=0.;
    }
  }
  Point d_v[4];
  Point d_a_e[3];
  //========== Compute the vertices inside the cell =========================**
  for(unsigned int i=0;i<3;i++){
    if(point_distance(p,v_e[i])<=radius){
      vert_inside.push_back(i);
    }
    else{
      vert_out.push_back(i);
    }
  }
  const unsigned int nv = vert_inside.size();
  //========== Compute the edges cutted by the cell =========================**
  for(unsigned int i=0;i<3;i++){
    double a_eq,b_eq,c_eq;
    int push_this = 0;
    int vi = (i+1)%3;
    d_a_e[i](0)=v_e[i](0)-v_e[vi](0);
    d_a_e[i](1)=v_e[i](1)-v_e[vi](1);
    a_eq = scalar_prod(d_a_e[i],d_a_e[i]);
    b_eq = 2*(scalar_prod(d_a_e[i],v_e[i])-scalar_prod(d_a_e[i],p));
    c_eq = scalar_prod(v_e[i],v_e[i])+scalar_prod(p,p)-2*scalar_prod(v_e[i],p)-pow(radius,2);
    if(pow(b_eq,2)>=4.*a_eq*c_eq){
      t_e[i][0]=(-b_eq-sqrt(pow(b_eq,2)-4.*a_eq*c_eq))/(2.*a_eq);
      t_e[i][1]=(-b_eq+sqrt(pow(b_eq,2)-4.*a_eq*c_eq))/(2.*a_eq);
      for(unsigned int j=0;j<2;j++){
	d_v[j].zero();
	d_v[j].add(v_e[i]);
	d_v[j].add_scaled(d_a_e[i],t_e[i][j]);
	if(point_distance(d_v[j],v_e[i]) < point_distance(v_e[i],v_e[vi]) && point_distance(d_v[j],v_e[vi]) < point_distance(v_e[i],v_e[vi])){part_edge[i][j]=1;push_this=1;}
      }
      if(push_this){edge_inside.push_back(i);}
    }
  }
  const unsigned int ne = edge_inside.size();
  //###########################################################################
  //                    0 vertices and 0 edges
  //###########################################################################
  if(nv==0 && ne==0){
    if(!cs_inside){
      return 0.;
    }
    else{
      return area_circ;
    }
  }
  //###########################################################################
  //                    0 vertices and 1 edges
  //###########################################################################
  if(nv==0 && ne==1){
    for(unsigned i=0; i<2; i++){
      d_v[i].zero();
      d_v[i].add(v_e[edge_inside[0]]);
      d_v[i].add_scaled(d_a_e[edge_inside[0]],t_e[edge_inside[0]][i]);
    }
    chord[0] = point_distance(d_v[0],d_v[1]);
    angle = 2.*asin(chord[0]/(2.*radius));
    area_cs[0] = 0.5*pow(radius,2)*(angle-sin(angle));
    if(!cs_inside){
      return area_cs[0];
    }
    else{
      return area_circ-area_cs[0];
    }
  }
  //###########################################################################
  //                    0 vertices and 2 edges
  //###########################################################################
  if(nv==0 && ne==2){
    if(!cs_inside){
      for(unsigned j=0; j<ne; j++){
	for(unsigned i=0; i<2; i++){
	  d_v[i].zero();
	  d_v[i].add(v_e[edge_inside[j]]);
	  d_v[i].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][i]);
	}
	chord[j] = point_distance(d_v[0],d_v[1]);
	angle = 2.*asin(chord[j]/(2.*radius));
	area_cs[j] = 0.5*pow(radius,2)*(angle-sin(angle));
      }
      if(chord[0]>chord[1]){return area_cs[0]-area_cs[1];}
      else{return area_cs[1]-area_cs[0];}
    }
    else{
      for(unsigned j=0; j<ne; j++){
	for(unsigned i=0; i<2; i++){
	  d_v[i].zero();
	  d_v[i].add(v_e[edge_inside[j]]);
	  d_v[i].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][i]);
	}
	chord[j] = point_distance(d_v[0],d_v[1]);
	angle = 2.*asin(chord[j]/(2.*radius));
	area_cs[j] = 0.5*pow(radius,2)*(angle-sin(angle));
      }
      return area_circ-area_cs[0]-area_cs[1];
    }
  }
  //###########################################################################
  //                    0 vertices and 3 edges
  //###########################################################################
  if(nv==0 && ne==3){
    if(!cs_inside){
      for(unsigned j=0; j<ne; j++){
	for(unsigned i=0; i<2; i++){
	  d_v[i].zero();
	  d_v[i].add(v_e[edge_inside[j]]);
	  d_v[i].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][i]);
	}
	chord[j] = point_distance(d_v[0],d_v[1]);
	angle = 2.*asin(chord[j]/(2.*radius));
	area_cs[j] = 0.5*pow(radius,2)*(angle-sin(angle));
      }
      if(chord[0]>chord[1] && chord[0]>chord[2]){return area_cs[0]-area_cs[1]-area_cs[2];}
      else if(chord[1]>chord[0] && chord[1]>chord[2]){return area_cs[1]-area_cs[0]-area_cs[2];}
      else{return area_cs[2]-area_cs[0]-area_cs[1];}
    }
    else{
      for(unsigned j=0; j<ne; j++){
	for(unsigned i=0; i<2; i++){
	  d_v[i].zero();
	  d_v[i].add(v_e[edge_inside[j]]);
	  d_v[i].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][i]);
	}
	chord[j] = point_distance(d_v[0],d_v[1]);
	angle = 2.*asin(chord[j]/(2.*radius));
	area_cs[j] = 0.5*pow(radius,2)*(angle-sin(angle));
      }
      return area_circ-area_cs[0]-area_cs[1]-area_cs[2];
    }
  }
  //###########################################################################
  //                    1 vertices and 2 edges
  //###########################################################################
  if(nv==1 && ne==2){
    for(unsigned j=0; j<ne; j++){
      d_v[j].zero();
      d_v[j].add(v_e[edge_inside[j]]);
      if(part_edge[edge_inside[j]][0]){d_v[j].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][0]);}
      else{                            d_v[j].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][1]);}
    }
    chord[0] = point_distance(d_v[0],d_v[1]);
    angle = 2.*asin(chord[0]/(2.*radius));
    area_cs[0] = 0.5*pow(radius,2)*(angle-sin(angle));
    area_t[0] = triangle_area(v_e[vert_inside[0]],d_v[0],d_v[1]);
    if(!cs_inside){return area_t[0]+area_cs[0];}
    else{
      double m1=(p(1)-v_e[vert_inside[0]](1))/(p(0)-v_e[vert_inside[0]](0));
      double m2=(d_v[0](1)-d_v[1](1))/(d_v[0](0)-d_v[1](0));
      Point Mid;
      Mid(0)=(p(1)-d_v[0](1)-m1*p(1)+m2*d_v[0](0))/(m2-m1);
      Mid(1)=p(1)+m1*(Mid(0)-p(0));
      double distAB = point_distance(p,v_e[vert_inside[0]]);
      double distAM = point_distance(p,Mid);
      double distBM = point_distance(v_e[vert_inside[0]],Mid);
      if(distAM<distAB && distBM<distAB){
	return area_circ-area_cs[0]+area_t[0];
      }
      else
	return area_t[0]+area_cs[0];
    }
  }
  //###########################################################################
  //                    1 vertices and 3 edges
  //###########################################################################
  if(nv==1 && ne==3){
    unsigned int count_j=0;
    for(unsigned j=0; j<ne; j++){
      if(part_edge[edge_inside[j]][0]){
	d_v[count_j].zero();
	d_v[count_j].add(v_e[edge_inside[j]]);
	d_v[count_j].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][0]);
	count_j++;
      }
      if(part_edge[edge_inside[j]][1]){
	d_v[count_j].zero();
	d_v[count_j].add(v_e[edge_inside[j]]);
	d_v[count_j].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][1]);
	count_j++;
      }
    }
    for(unsigned j=0; j<2; j++){
      double distA,distB;
      int posA,posB;
      distA = distB = 1e5;
      posA = posB = 0;
      for(int i=0;i<4;i++){
	double dist_t = point_distance(v_e[vert_out[j]],d_v[i]);
	if(dist_t<distA){
	  distB=distA;
	  posB=posA;
	  distA = dist_t;
	  posA = i;
	}
	else if(dist_t<distB){
	  distB = dist_t;
	  posB = i;
	}
      }
      chord[j] = point_distance(d_v[posA],d_v[posB]);
      angle = 2.*asin(chord[j]/(2.*radius));
      area_cs[j] = 0.5*pow(radius,2)*(angle-sin(angle));
      area_t[j] = triangle_area(v_e[vert_out[j]],d_v[posA],d_v[posB]);
    }
    if(!cs_inside){return elem_volume-area_t[0]+area_cs[0]-area_t[1]+area_cs[1];}
    else{return elem_volume-area_t[0]+area_cs[0]-area_t[1]+area_cs[1];}
  }
  //###########################################################################
  //                    2 vertices and 2 edges
  //###########################################################################
  if(nv==2 && ne==2){
    for(unsigned j=0; j<ne; j++){
      d_v[j].zero();
      d_v[j].add(v_e[edge_inside[j]]);
      if(part_edge[edge_inside[j]][0]){d_v[j].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][0]);}
      else{                            d_v[j].add_scaled(d_a_e[edge_inside[j]],t_e[edge_inside[j]][1]);}
    }
    chord[0] = point_distance(d_v[0],d_v[1]);
    angle = 2.*asin(chord[0]/(2.*radius));
    area_cs[0] = 0.5*pow(radius,2)*(angle-sin(angle));
    area_t[0] = triangle_area(v_e[vert_out[0]],d_v[0],d_v[1]);
    if(!cs_inside){return elem_volume-area_t[0]+area_cs[0];}
    else{return elem_volume-area_t[0]+area_cs[0];}
  }
  //###########################################################################
  //                    3 vertices and 0 edges
  //###########################################################################
  if(nv==3 && ne==0){
    if(!cs_inside){return elem_volume;}
    else{return elem_volume;}
  }
  return 0.;
}

void initial_condition_ox(EquationSystems& es,const std::string& libmesh_dbg_var(system_name)){
  libmesh_assert_equal_to(system_name,"Nutrient");
  TransientLinearImplicitSystem & sys = es.get_system<TransientLinearImplicitSystem>("Nutrient");
  es.parameters.set<Real>("time") = sys.time = 0;
  sys.project_solution(exact_value_ox,NULL,es.parameters);
}
void initial_condition_vegf(EquationSystems& es,const std::string& libmesh_dbg_var(system_name)){
  libmesh_assert_equal_to(system_name,"VEGF");
  TransientLinearImplicitSystem & sys = es.get_system<TransientLinearImplicitSystem>("VEGF");
  es.parameters.set<Real>("time") = sys.time = 0;
  sys.project_solution(exact_value_ox,NULL,es.parameters);
}
void initial_condition_vessel(EquationSystems& es,const std::string& libmesh_dbg_var(system_name)){
  libmesh_assert_equal_to(system_name,"Vessel");
  TransientLinearImplicitSystem & sys = es.get_system<TransientLinearImplicitSystem>("Vessel");
  es.parameters.set<Real>("time") = sys.time = 0;
  sys.project_solution(exact_value_vessel,NULL,es.parameters);
}

void assemble_ox(EquationSystems& es,const std::string& libmesh_dbg_var(system_name)){
  libmesh_assert_equal_to (system_name, "Diffusion");
  const MeshBase& mesh = es.get_mesh();
  const unsigned int dim = mesh.mesh_dimension();
  TransientLinearImplicitSystem & system = es.get_system<TransientLinearImplicitSystem>("Nutrient");
  const unsigned int v_nut = system.variable_number("nut_var");
  const Real time_size = es.parameters.get<Real>("time_step_size");
  const Real nut_d = es.parameters.get<Real>("nut_d");
  const Real con_b = es.parameters.get<Real>("con_b");
  const Real con_t = es.parameters.get<Real>("con_t");
  const Real con_n = es.parameters.get<Real>("con_n");
  const Real end_r = es.parameters.get<Real>("end_r");
  const Real mesh_x = es.parameters.get<Real>("mesh_x");
  const Real mesh_y = es.parameters.get<Real>("mesh_y");
  const int nut_coeff = es.parameters.get<Real>("nut_coeff");
  const Real ac_radius = es.parameters.get<Real>("action_radius");
  const Real h_max_msh = es.parameters.get<Real>("h_max_mesh");
  const Real height    = es.parameters.get<Real>("domain_diameter");
  list <Cell> *Cells_local = es.parameters.get<list <Cell> *>("l_cells");
  const double h_bin   = ac_radius+h_max_msh;
  const int number_bins0 = ceil(mesh_x/h_bin);
  const int number_bins1 = ceil(mesh_y/h_bin);
  const int total_bins  = number_bins0*number_bins1;
//cout << "total bins = " << total_bins << "  ###########################" << endl;
  //========== Generate bins ==========
  vector< list < Cell * > > Cell_Bins(total_bins);
  std::list<Cell>::iterator it;
  for(it = Cells_local->begin(); it != Cells_local->end(); ++it){
    int ix = floor((*it).x/h_bin);
    int jy = floor((*it).y/h_bin);
    int xy = ix+jy*number_bins0;
    if( (*it).state == 7 ) {
 //  cout << "cell.x = " << (*it).x << " (*it).y = " << (*it).y << endl;

    }
    if((*it).x<0 || (*it).y<0 || (*it).x> mesh_x || (*it).y> mesh_y || jy>=number_bins1 || ix>=number_bins0 || xy >=total_bins){
      cout << "Error" << endl;
      cout << "Cell = ( " << (*it).x << " , " << (*it).y << " ) = ( " << ix << " , " << jy << " ) = " << xy << endl;
      cout << "State = " << (*it).state << endl;
      cout << "total_bins  = " << total_bins << endl;
      cout << "number_bins0 = " << number_bins0 << endl;
      cout << "number_bins1 = " << number_bins1 << endl;
      cout << "h_bin       = " << h_bin << endl;
      getchar();
    }
    Cell_Bins[xy].push_back(&*it);
  }
  //========== Continue stnd ==========    
  const DofMap& dof_map = system.get_dof_map();
  FEType fe_type = dof_map.variable_type(0);
  UniquePtr<FEBase> fe (FEBase::build(dim, fe_type));
  QGauss qrule (dim, fe_type.default_quadrature_order());
  fe->attach_quadrature_rule (&qrule);
  const std::vector<Real>& JxW = fe->get_JxW();
  const std::vector<std::vector<Real> >& phi = fe->get_phi();
  const std::vector<std::vector<RealGradient> >& dphi = fe->get_dphi();
  DenseMatrix<Number> Ke;
  DenseVector<Number> Fe;
  std::vector<dof_id_type> dof_indices;
  std::vector<dof_id_type> dof_indices_nut;
  MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
  const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
  for ( ; el != end_el ; ++el){
    const Elem* elem = *el;
    //========== Computed volume fraction ==========
    Point e_center = elem->centroid();
    int ix = floor(e_center(0)/h_bin);
    int jy = floor(e_center(1)/h_bin);
    double p_t,p_n,p_e,p_tip,p_s,p_gs;
    double elem_volume = elem->volume();
    p_t = p_n = p_e = p_tip = p_s = p_gs = 0.;
    for(int xx = -1; xx<=1; xx++){
      if(ix+xx>=0 && ix+xx<number_bins0){
	for(int yy = -1; yy<=1; yy++){
	  if(jy+yy>=0 && jy+yy<number_bins1){
	    int bin_xy = (ix+xx)+(jy+yy)*number_bins0;
	    std::list<Cell*>::iterator cell_ab;
	    for(cell_ab = Cell_Bins[bin_xy].begin(); cell_ab != Cell_Bins[bin_xy].end(); ++cell_ab){
	      if( (*(*cell_ab)).state == 0 || (*(*cell_ab)).state == 4 || ( (*(*cell_ab)).state == 7 && (*(*cell_ab)).activate != 2)  ) continue;
	      else{
		Point p( (*(*cell_ab)).x,(*(*cell_ab)).y,0.);
		double area_computed = 0.;
		if(elem->type()==3){
		  area_computed = area_inside_tri(p,elem->point(0),elem->point(1),elem->point(2),(*(*cell_ab)).C_radius,elem_volume);
		}
		else{
		  area_computed = area_inside_quad(p,elem->point(0),elem->point(1),elem->point(2),elem->point(3),(*(*cell_ab)).C_radius);
		}
		if(area_computed > 0){
double area = 3.1415926535*pow( (*(*cell_ab)).C_radius , 2);
		  if((*(*cell_ab)).state == 6) p_n+=(area_computed/area);
//		  else if((*(*cell_ab)).state >= 7 && (*(*cell_ab)).state != 13) p_e+=(area_computed/elem_volume);
//		  else if((*(*cell_ab)).state >= 7 && (*(*cell_ab)).state != 13) p_e+=(area_computed/area);
		  else if((*(*cell_ab)).state >= 7 && (*(*cell_ab)).activate == 2) p_s+=(area_computed/area);
//		  else if((*(*cell_ab)).state >= 7 && (*(*cell_ab)).prev_state == 7) p_e+=(area_computed/area);
                 else if( (*(*cell_ab)).state >= 0 && (*(*cell_ab)).state <= 6) p_t+=(area_computed/area);
		}
	      }
	    }
	  }
	}
      }
    }
    double p_b;
    if((p_t+p_n+p_e)>1.0){p_b = 0.;}
    else{p_b=1.0-(p_t+p_n+p_e);}
    //========== Continue stnd ==========  
    dof_map.dof_indices(elem,dof_indices);
    dof_map.dof_indices(elem,dof_indices_nut,v_nut);
    fe->reinit(elem);
    Ke.resize(dof_indices.size(),dof_indices.size());
    Fe.resize(dof_indices.size());
    for (unsigned int qp=0; qp<qrule.n_points(); qp++){
      Number nut_old = 0.0;
      for(unsigned int l=0; l<phi.size(); l++){
	nut_old += phi[l][qp]*system.old_solution(dof_indices_nut[l]);
      }
      for (unsigned int i=0; i<phi.size(); i++){
	Fe(i) += JxW[qp]*(nut_old
			  +time_size*nut_coeff*(p_e+p_tip+p_s+p_gs)*end_r
			  )*phi[i][qp];
	for (unsigned int j=0; j<phi.size(); j++){
	  Ke(i,j) += JxW[qp]*time_size*nut_d*dphi[i][qp]*dphi[j][qp];
	  Ke(i,j) += JxW[qp]*(1.0+time_size*(p_b*con_b+
					     p_n*con_n+
					     p_t*con_t+
					     nut_coeff*(p_e+p_tip+p_s+p_gs)*end_r))*phi[i][qp]*phi[j][qp];
	}
      }
    }
    dof_map.heterogenously_constrain_element_matrix_and_vector(Ke,Fe,dof_indices);
    system.matrix->add_matrix (Ke,dof_indices);
    system.rhs->add_vector    (Fe,dof_indices);
  }
}
